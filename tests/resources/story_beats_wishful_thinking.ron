[
    Beat(
        // the actors, whose aliases will get matched at runtime with entities that satisfy the constraints.
        // How to differentiate these dynamic aliases with entities created for this beat? ie. the letter.
        entities: {
            "messenger": "character",
            "noble woman": "character",
            "letter": "object",
        },
        
        // Indicates that the following aliases must not match an existing entity, but rather
        // bind to a new entity constructed for this beat.
        new_entities: {
            "letter": { // creates a new entity with the following properties
                "name": "urgent letter",
                "object type": "letter",
                "content": "Dear {PROTAG.gender.title} {PROTAG.family name},"
            },
        },

        // Constraints on aliases which must be satisfied for this beat to play
        constraints: {
            "TIME": [
                IsOne("{time of day}", ["morning", "midday"]), 
            ],
            "PROTAG": [
                IsGreaterEq("{level}", 3),
                Any("in", "city"),  // PROTAG has a relationship "in" with any entity of type "city"
                                    // Meaning we are currently in a city. Could also be handled by
                                    // a global "LOCATION" entity.
            ],
            "noble woman": [
                // the "noble woman" is implicit, all constraints are related to the current alias
                // Constraints on properties. Are {} required?
                Eq("{wealth}", "rich"),
                Eq("{gender}", "female"),
                Eq("knows", "PROTAG", "acquaintance"),
            ],
            "messenger": [
                Eq("carries", "letter"), // A better word than Eq for relationships?
            ],
        },

        
        // The graph of instructions
        scenario: {
            // start node is always named "start"
            "start": (
                next: ["accept", "refuse"],
                constraints: [],
                instructions: [
                    ( // event tuple contains the event's label followed by it concrete properties
                        "say",
                        {
                            "who": "messenger",
                            "speech": "Pardon, are you the one called {PROTAG.gender.gendered title short} {PROTAG.family name}? I bring an urgent message on the part of lady {noble woman.family name}.",
                        }
                    ),
                ]
            ),

            "refuse": (
                next: ["end"],
                constraints: [],
                instructions: [
                    (
                        "say",
                        "PROTAG",
                        "I do not wish to involve myself with lady {noble woman.family name}. Good day."
                    ),
                    (
                        "offend",
                        "PROTAG",
                        "noble woman",
                        "petty",
                    ),
                ],
            ),

            "accept": (
                next: ["details"],
                constraints: [],
                instructions: [
                    (
                        "say",
                        "PROTAG",
                        "Sounds exciting! Well, out with it!"
                    ),
                ]
            ),

            "details": (
                next: ["end"],
                constraints: [],
                instructions: [
                    (
                        "give",
                        "messenger",
                        "PROTAG",
                        "letter",
                    )
                ]
            )
        }
    )
]
